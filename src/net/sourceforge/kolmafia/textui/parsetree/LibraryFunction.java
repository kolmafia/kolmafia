package net.sourceforge.kolmafia.textui.parsetree;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import net.sourceforge.kolmafia.KoLmafia;
import net.sourceforge.kolmafia.RequestLogger;
import net.sourceforge.kolmafia.StaticEntity;
import net.sourceforge.kolmafia.textui.AshRuntime;
import net.sourceforge.kolmafia.textui.RuntimeLibrary;
import net.sourceforge.kolmafia.textui.ScriptException;
import net.sourceforge.kolmafia.textui.ScriptRuntime;

public class LibraryFunction extends Function {
  private final Method method;
  public final String[] deprecationWarning;

  public LibraryFunction(
      final String name,
      final Type type,
      final List<VariableReference> variableReferences,
      final String... deprecationWarning) {
    super(name.toLowerCase(), type, variableReferences, null);

    this.deprecationWarning = deprecationWarning;

    this.method = findLibraryMethod(name, variableReferences.size());
  }

  private static Method findLibraryMethod(String name, int paramCount) {
    try {
      Class<?>[] args = new Class[paramCount + 1];

      args[0] = ScriptRuntime.class;
      Arrays.fill(args, 1, args.length, Value.class);

      return RuntimeLibrary.findMethod(name, args);
    } catch (Exception e) {
      // This should not happen; it denotes a coding
      // error that must be fixed before release.

      StaticEntity.printStackTrace(e, "No method found for built-in function: " + name);
      return null;
    }
  }

  @Override
  public Value execute(final AshRuntime interpreter, Object[] values) {
    if (!KoLmafia.permitsContinue()) {
      interpreter.setState(ScriptRuntime.State.EXIT);
      return null;
    }

    if (StaticEntity.isDisabled(this.getName())) {
      this.printDisabledMessage(interpreter);
      return this.getType().initialValue();
    }

    if (this.method == null) {
      throw interpreter.runtimeException("Internal error: no method for " + this.getName());
    }

    try {
      // Bind values to variable references.
      // Collapse values into VarArgs array
      values = this.bindVariableReferences(interpreter, values);

      // Invoke the method
      return (Value) this.method.invoke(this, values);
    } catch (InvocationTargetException e) {
      // This is an error in the called method. Pass
      // it on up so that we'll print a stack trace.

      Throwable cause = e.getCause();
      if (cause instanceof ScriptException) {
        // Pass up exceptions intentionally generated by library
        throw (ScriptException) cause;
      }
      throw new RuntimeException(cause);
    } catch (IllegalAccessException e) {
      // This is not expected, but is an internal error in ASH
      throw new ScriptException(e);
    }
  }

  // This is necessary for calls into the runtime library from other languages.
  public Value executeWithoutInterpreter(ScriptRuntime controller, Object[] values) {
    if (StaticEntity.isDisabled(this.getName())) {
      RequestLogger.printLine("Called disabled function: " + this.getName());
      return this.getType().initialValue();
    }

    if (this.method == null) {
      throw controller.runtimeException("Internal error: no method for " + this.getName());
    }

    try {
      // Collapse values into VarArgs array
      values = this.bindVariableReferences(null, values);

      // Invoke the method
      return (Value) this.method.invoke(this, values);
    } catch (InvocationTargetException e) {
      // This is an error in the called method. Pass
      // it on up so that we'll print a stack trace.

      Throwable cause = e.getCause();
      if (cause instanceof ScriptException) {
        // Pass up exceptions intentionally generated by library
        throw (ScriptException) cause;
      }
      throw new RuntimeException(cause);
    } catch (IllegalAccessException e) {
      // This is not expected, but is an internal error in ASH
      throw new ScriptException(e);
    }
  }

  public List<String> getParameterNames() {
    return this.variableReferences.stream()
        .map(VariableReference::getName)
        .collect(Collectors.toList());
  }
}
