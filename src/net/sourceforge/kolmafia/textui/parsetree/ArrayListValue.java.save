package net.sourceforge.kolmafia.textui.parsetree;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import net.sourceforge.kolmafia.textui.AshRuntime;
import net.sourceforge.kolmafia.textui.DataTypes.TypeSpec;
import org.json.JSONArray;
import org.json.JSONException;

public class ArrayListValue extends AggregateValue {
  public ArrayListValue(final AggregateType type) {
    super(type);

    // An array has an initial size.
    // It is indexed from 0 to (size - 1)

    int size = type.getSize();
    ArrayList<Value> content = new ArrayList<>(size);

    // Implemented as an ArrayList, the underlying array is resizable -
    // via add and remove - but gets must be within bounds

    Type dataType = type.getDataType();
    // Initialize with the default value of the data type.

    for (int i = 0; i < size; ++i) {
      content.add(i, dataType.initialValue());
    }

    this.content = content;
  }

  public ArrayListValue(final AggregateType type, final List<Value> values) {
    super(type);

    int size = values.size();
    type.setSize(size);

    // An array has an initial size.
    // It is indexed from 0 to (size - 1)

    ArrayList<Value> content = new ArrayList<>(size);

    // Implemented as an ArrayList, the underlying array is resizable -
    // via add and remove - but gets must be within bounds

    int index = 0;
    // Initialize with the specified initial content
    for (Value val : values) {
      content.add(index, val);
    }

    this.content = content;
  }

  @Override
  public Value aref(final Value key, final AshRuntime interpreter) {
    ArrayList<Value> array = (ArrayList<Value>) this.content;

    // Implemented as an ArrayList, the underlying array is resizable -
    // via add and remove - but gets must be within bounds

    int index = (int) key.intValue();
    int size = array.size();
    if (index < 0 || index >= size) {
      System.out.println("aref");
      throw interpreter.runtimeException(
          "Array index [" + index + "] out of bounds (" + size + ")");
    }
    return array.get(index);
  }

  @Override
  public void aset(final Value key, final Value val, final AshRuntime interpreter) {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int size = array.size();

    int index = (int) key.intValue();
    if (index < 0) {
      System.out.println("aset");
      throw interpreter.runtimeException(
          "Array index [" + index + "] out of bounds (" + size + ")");
    }

    // We must be able to coerce the supplied value into an acceptable value

    AggregateType type = (AggregateType)this.type;
    Type dataType = type.getDataType();
    Type baseType = dataType.getBaseType();
    Type valType = val.getType();

    Value data = 
        baseType.equals(valType) ?
        val :
        baseType.equals(TypeSpec.STRING) ?
        val.toStringValue() :
        (baseType.equals(TypeSpec.INT) && valType.equals(TypeSpec.FLOAT)) ?
        val.toIntValue() :
        (baseType.equals(TypeSpec.FLOAT) && valType.equals(TypeSpec.INT)) ?
        val.toFloatValue() :
        null;

    if (data == null) {
      throw interpreter.runtimeException(
          "Internal error: Cannot assign " + valType + " to " + dataType);
    }

    // Implemented as an ArrayList, the underlying array is resizable

    if (index >= size) {
      type.setSize(index);

      // Fill in default values between end of original array and new index
      for (int i = size; i <= index; ++i) {
        array.add(i, dataType.initialValue());
      }
    }

    array.set(index, data);
  }

  @Override
  public Value remove(final Value key, final AshRuntime interpreter) {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int index = (int) key.intValue();
    int size = array.size();

    if (index < 0 || index >= size) {
      System.out.println("remove");
      throw interpreter.runtimeException(
          "Array index [" + index + "] out of bounds (" + size + ")");
    }
    Value result = array.get(index);
    array.remove(index);
    return result;
  }

  @Override
  public void clear() {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int size = array.size();
    Type dataType = this.getDataType();

    for (int i = 0; i < size; ++i) {
      array.set(i, dataType.initialValue());
    }
  }

  @Override
  public int count() {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    return array.size();
  }

  @Override
  public boolean contains(final Value key) {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int size = array.size();
    int index = (int) key.intValue();
    return index >= 0 && index < size;
  }

  @Override
  public Value[] keys() {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int size = array.size();
    Value[] result = new Value[size];
    for (int i = 0; i < size; ++i) {
      result[i] = new Value(i);
    }
    return result;
  }

  @Override
  public void dump(final PrintStream writer, final String prefix, final boolean compact) {
    if (!compact || this.type.dataValues() < 0) {
      super.dump(writer, prefix, compact);
      return;
    }

    writer.print(prefix);
    this.dumpValue(writer);
    writer.println();
  }

  @Override
  public void dumpValue(final PrintStream writer) {
    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int count = array.size();

    if (count == 0) {
      return;
    }

    for (int i = 0; i < count; ++i) {
      if (i > 0) {
        writer.print("\t");
      }
      array.get(i).dumpValue(writer);
    }
  }

  @Override
  public int read(
      final String[] data,
      int index,
      final boolean compact,
      final String filename,
      final int line) {
    if (!compact || this.type.dataValues() < 0) {
      return super.read(data, index, compact, filename, line);
    }

    ArrayList<Value> array = (ArrayList<Value>) this.content;
    int count = array.size();

    // *** Zero-length array reading done in CompositeValue
    if (count == 0) {
      return 0;
    }

    int size = Math.min(count, data.length - index);
    int first = index;
    Type valType = this.getDataType();

    // Consume remaining data values and store them
    for (int offset = 0; offset < size; ++offset) {
      if (valType instanceof RecordType) {
        RecordValue rec = (RecordValue) array.get(offset);
        index += rec.read(data, index, true, filename, line);
      } else {
        array.set(offset, Value.readValue(valType, data[index], filename, line));
        index += 1;
      }
    }

    // assert index == data.length
    return index - first;
  }

  @Override
  public Object toJSON() throws JSONException {
    var obj = new JSONArray();

    ArrayList<Value> array = (ArrayList<Value>) this.content;
    for (var value : array) {
      obj.put(value.toJSON());
    }

    return obj;
  }
}
